---
author: Fluent Data, LLC
date: '`r Sys.Date()`'
description: |
  This lesson teaches how to create custom R functions, use conditional statements to make decisions in your code, loop through data with for loops, and efficiently apply functions to data structures using the apply function.
title: 4 .  Writing Functions, Conditionals, and Loops
output:
  learnr::tutorial:
    allow_skip: yes
runtime: shiny_prerendered
---


```{r setup, include=FALSE}
library(learnr)
library(gradethis)
library(trainingRIntro)
library(shiny)
```

This lesson covers how to write your own R functions. It also explains how to automate
your code using `if()` and `ifelse()` functions, for loops, and the `apply`
function.

## Prerequisites

This lesson assumes you are familiar with the material in the previous lessons:

- [Functions and Importing Data](../2-Functions-and_Importing-Data/readme.md)
- [Subsetting, Sorting, and Combining Data Frames](../3-Subsetting-Sorting-and-Combining/readme.md).

The data for these lessons is available from this package. It is assumed that this package is already installed and loaded into the R session. If you need to refer to the package, simply refer to it as "this package".


```{r ex-uqM3N-1, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'Load Data from This Package'}
# Assuming the package is already loaded

data(chicago_air)

```

## Writing Functions

As discussed in the [second lesson on functions](../2-Functions-and_Importing-Data/readme.md),
R can execute a saved chunk of code by running the name of a function, like `mean()`.
The name `mean` is saved like a variable name, but since the name refers to a function,
the thing that's saved is not a data object but lines of R code.

To save your own function, use this construction:


```{r ex-0KxG9-1, eval = FALSE, exercise = TRUE, exercise.cap = 'Creating Your Own Function'}
my_function_name <- function() {

  # lines of R code

}

```

We can write a simple function that prints something to the console. Here is a
function named `print_hello`.


```{r ex-qvWQW-2, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'Simple Function to Print Hello'}
print_hello <- function() {

  print("Hello")

}

```

```{r ex-7YnpO-3, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'Testing the print_hello Function'}
print_hello()

```

## Arguments

Most of the functions we have used in these lessons have had at least one argument
inside of the parentheses. The `print_hello()` function did not have any arguments,
so we could run it without putting anything inside `()`. We could modify the
function to take an argument that pastes some text to the printed message.

Here we recreate the same function, but this time we add an argument `text` inside
of the parentheses.


```{r ex-vn8sm-1, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'Function with an Argument'}
print_hello <- function(text) {

  message <- paste("Hello", text)

  print(message)

}

```

```{r ex-r0twA-2, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'Testing the Modified print_hello Function'}
print_hello(text = "everybody!")

```

## Default Values

We can create a function with more than one argument, and set default values when
needed. Suppose we would like to make a function that checks if a measurement is below
a criteria pollutant standard. We could make simple function that takes two arguments:
one for the measurement value, and one for the standard value.


```{r ex-HmsJT-1, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'Function with Two Arguments'}
check_standard <- function(measurement, standard) {

  measurement > standard

}

```

```{r ex-53CNb-2, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'Testing check_standard Function'}
check_standard(measurement = 84, standard = 70)

```

We could write a more specific function for checking a value against the ozone
standard. For this function, we want to keep the `standard` parameter but make sure
the default is `70`. It may be that we typically want to use this function to
check against the current 8-hour ozone standard in parts per billion, but have
then flexibility to use a different value.

To set a default value, we use `= 70` when we create the function.


```{r ex-iWazW-3, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'Function with Default Value'}
check_standard <- function(measurement, standard = 70) {

  measurement > standard

}

```

```{r ex-bCrRC-4, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'Testing check_standard with Default Value'}
check_standard(measurement = 50)

```

## Positional Arguments

One final note on functions in R. When a function is created, the order of the
arguments are important. The user can supply values for the arguments in the order
they appeared in the parentheses of the `function( ){}` call, without writing out
the argument names.

For example, we can supply two numbers to the `check_standard()` function that we
created above, without writing out the `measurement` and `standard` arguments.
When R executes the function, it will assign the numbers to the arguments
based on the position in the parentheses.

Here we show that using two numbers in a different order will return different
outputs.


```{r ex-ihRr3-1, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'Testing Positional Arguments'}
check_standard(60, 70)

```

```{r ex-jSEHz-2, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'Testing Positional Arguments in Reverse Order'}
check_standard(70, 60)

```

## if Functions

Writing custom functions is a good way to standardize some R code that can be reused
on different data sets. It's also helpful to write code that will execute different
lines of code depending on different scenarios. The functions `if()` and `ifelse()`
allow you to control what code is executed based on a logical condition.

The `if()` function takes the logical condition in the parentheses. The code that
will run if the logical expression is `TRUE` is placed inside curly braces. Below
is the outline (not actual R code).


```{r ex-UsrG4-1, eval = FALSE, exercise = TRUE, exercise.cap = 'if Function Outline'}
if(logical expression>) {

  <code that will run if the logical expression is TRUE>

}

```

```{r ex-XKaWg-2, eval = FALSE, exercise = TRUE, exercise.cap = 'if-else Function Outline'}
if(<logical expression>) {

  <code that will run if the logical expression is true>

} else {

  <code that will run if the logical expression is false>

}

```

```{r ex-7jJXi-3, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'if Function Example'}
ozone <- 0.075

if(ozone > 0.065) {

  print("Potential Health Effects")

} else {

  print("All Good")

}

```

```{r ex-PqKQb-4, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'Another if Function Example'}
ozone <- 0.06

if(ozone > 0.065) {

  print("Potential Health Effects")

} else {

  print("All Good")

}

```

```{r ex-bMcX0-5, eval = FALSE, exercise = TRUE, exercise.cap = 'ifelse Function Outline'}
ifelse(<test>, <yes>, <no>)

```

```{r ex-fisPk-6, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'ifelse Function Example'}
ozone_value <- 0.06

message <- ifelse(ozone_value > 0.065, "Potential Health Effects", "All Good")

print(message)

```

## For loop

Like most programming languages, R has for and while loops. This tutorial will
cover just for loops and move on to `apply()` functions, which are more commonly
used in R.

For loops are used to repeat an operation a set number of times. Here is the
basic outline:


```{r ex-4kY8A-1, eval = FALSE, exercise = TRUE, exercise.cap = 'For Loop Outline'}
for(i in sequence){

  <code that will run a set number of times>

}

```

```{r ex-FNkLh-2, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'For Loop Example'}
for(i in c(1, 2, 3)) {

  print(i)

}

```

Typically when we use loops, we want to perform the same operation on different
sets of data and save the results. To do this using the `for()` function in R,
we need to create an empty vector (or list or data frame) and save the results
during each iteration.

Here is an example data frame we will use. It represents a few values from three
monitors.


```{r ex-aDbOs-3, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'For Loop with Data Frame'}
monitors <- data.frame(monitor1 = c(50, 60, 58, 52),
                       monitor2 = c(55, 59, 65, 61),
                       monitor3 = c(70, 62, 68, 71))

monitors

```

```{r ex-krXCI-4, exercise = TRUE, exercise.eval = FALSE, exercise.cap = 'Finding Maximum Values with For Loop'}
max_values <- c()

for(i in c(1, 2, 3)) {

  max_values[i] <- max(monitors[, i])

}

max_values

```

## apply function

Although the for loop is common in programming languages, it is not the most
efficient way to apply a function to different sets of data in R. The most efficient
way to do loops in R is with the `apply()` family of functions, including `lapply()`,
`tapply()`, and `mapply()`. This section will demonstrate how to use the `apply()`
function.

The `apply()` function takes a data frame (or matrix) as the first argument. The
second argument determines if each loop will apply to the rows (`1`) or columns
(`2`). And the third argument is the function you want to apply to each row or column.
Additional arguments can be used to pass on to the function being applied to each
row or column.

The example below applies the `max()` function to the `monitors` data frame from
the previous section.


```{r ex-6BUHA-1, eval = FALSE, exercise = TRUE, exercise.cap = 'apply Function Example'}
monitors_max <- apply(monitors, MARGIN = 2, FUN = max)

monitors_max

```


## Exercises {data-progressive=TRUE}

### Exercise 1

Write a function named `ppm_to_ppb` that converts a value from parts per million to parts per billion.

```{r exercise1, exercise = TRUE}
# Your code here
```

```{r exercise1-hint-1}
# Define the function `ppm_to_ppb` with one argument for the value you want to convert.
```

```{r exercise1-hint-2}
# Inside the function, multiply the input value by 1000 to convert it to parts per billion.
```

```{r exercise1-hint-3}
# Return the converted value.
```

```{r exercise1-solution}
ppm_to_ppb <- function(value) {
  value * 1000
}

```

```{r exercise1-check}
grade_this_code(
  correct = c(gradethis::random_praise(), "The function `ppm_to_ppb` converts a given value from parts per million (ppm) to parts per billion (ppb) by multiplying the value by 1000, since 1 ppm is equal to 1000 ppb. ")
)
```


### Exercise 2

Write a function named `check_value` that prints "warning" if a value is above a threshold, and "OK" if it's below. Make the threshold an argument in the function.

```{r exercise2, exercise = TRUE}
# Your code here
```

```{r exercise2-hint-1}
# Define the function `check_value` with two arguments: `value` and `threshold`.
```

```{r exercise2-hint-2}
# Use an `if` statement to check if `value` is greater than `threshold`.
```

```{r exercise2-hint-3}
# Print "warning" if the value is above the threshold, otherwise print "OK".
```

```{r exercise2-solution}
check_value <- function(value, threshold) {
  if(value > threshold) {
    print("warning")
  } else {
    print("OK")
  }
}

```

```{r exercise2-check}
grade_this_code(
  correct = c(gradethis::random_praise(), "The function `check_value` takes two arguments: a value and a threshold. It uses an if-else statement to print "warning" if the value is greater than the threshold, and "OK" if it's not, effectively monitoring values against a set benchmark. ")
)
```


### Exercise 3

Use the `for()` function to loop through the `temp` column of the data from this package and print any value that is above 90 degrees.

```{r exercise3, exercise = TRUE}
# Your code here
```

```{r exercise3-hint-1}
# Access the `temp` column of the data frame within the loop.
```

```{r exercise3-hint-2}
# Use a `for` loop to iterate over each value in the `temp` column.
```

```{r exercise3-hint-3}
# Inside the loop, use an `if` statement to check if the current temperature value is greater than 90.
```

```{r exercise3-hint-4}
# If a value is above 90, use `print()` to display it.
```

```{r exercise3-solution}
for (i in chicago_air$temp) {
  if(i > 90) {
    print(i)
  }
}

```

```{r exercise3-check}
grade_this_code(
  correct = c(gradethis::random_praise(), "This loop iterates over each value in the `temp` column of the data frame, checking each temperature against the criterion of being greater than 90 degrees. If a temperature exceeds this threshold, it is printed, allowing for a simple scan of unusually high temperatures. ")
)
```


### Exercise 4

Use the `apply()` function to create a vector of the mean values from the numeric columns in the data from this package.

```{r exercise4, exercise = TRUE}
# Your code here
```

```{r exercise4-hint-1}
# First, subset the data frame to include only the numeric columns you wish to analyze.
```

```{r exercise4-hint-2}
# Use the `apply()` function with the subsetted data frame, specifying `MARGIN = 2` to apply the function across columns.
```

```{r exercise4-hint-3}
# Use the `mean` function as the `FUN` argument, including `na.rm = TRUE` to handle missing values.
```

```{r exercise4-solution}
chicago_numeric <- chicago_air[, c("ozone", "temp", "pressure")]
mean_values <- apply(chicago_numeric, MARGIN = 2, FUN = mean, na.rm = TRUE)
mean_values
```

```{r exercise4-check}
grade_this_code(
  correct = c(gradethis::random_praise(), "To compute the mean values of the numeric columns in the data frame, we first isolate these columns into a new data frame. Then, the `apply()` function is used to calculate the mean of each, ensuring to remove any `NA` values with `na.rm = TRUE`. This produces a vector of mean values for the columns specified. ")
)
```




## Next Lesson


You have completed Lesson {lesson$no}. Click the button below to mark it as complete and move on to the next lesson.

```{r example-button, echo=FALSE}
  actionButton("complete_lesson", "Mark Lesson 4 Complete")
```


```{r, context = "server"}
  observeEvent(input$complete_lesson, {
    shiny::stopApp()
    trainingRIntro::set_user_state(lesson_4_complete=TRUE)
  })
```




